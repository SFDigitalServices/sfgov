{#
/**
 * @file
 * Default theme implementation to display a paragraph.
 *
 * Available variables:
 * - paragraph: Full paragraph entity.
 *   Only method names starting with "get", "has", or "is" and a few common
 *   methods such as "id", "label", and "bundle" are available. For example:
 *   - paragraph.getCreatedTime() will return the paragraph creation timestamp.
 *   - paragraph.id(): The paragraph ID.
 *   - paragraph.bundle(): The type of the paragraph, for example, "image" or "text".
 *   - paragraph.getOwnerId(): The user ID of the paragraph author.
 *   See Drupal\paragraphs\Entity\Paragraph for a full list of public properties
 *   and methods for the paragraph object.
 * - content: All paragraph items. Use {{ content }} to print them all,
 *   or print a subset such as {{ content.field_example }}. Use
 *   {{ content|without('field_example') }} to temporarily suppress the printing
 *   of a given child element.
 * - attributes: HTML attributes for the containing element.
 *   The attributes.class element may contain one or more of the following
 *   classes:
 *   - paragraphs: The current template type (also known as a "theming hook").
 *   - paragraphs--type-[type]: The current paragraphs type. For example, if the paragraph is an
 *     "Image" it would result in "paragraphs--type--image". Note that the machine
 *     name will often be in a short form of the human readable label.
 *   - paragraphs--view-mode--[view_mode]: The View Mode of the paragraph; for example, a
 *     preview would result in: "paragraphs--view-mode--preview", and
 *     default: "paragraphs--view-mode--default".
 * - view_mode: View mode; for example, "preview" or "full".
 * - logged_in: Flag for authenticated user status. Will be true when the
 *   current user is a logged-in member.
 * - is_admin: Flag for admin user status. Will be true when the current user
 *   is an administrator.
 *
 * @see template_preprocess_paragraph()
 *
 * @ingroup themeable
 */
#}
{% set endpoint = paragraph.field_formio_data_source.value|trim %}
{% set form_id = content.field_formio_data_source['#formio_id']|clean_id %}
{% set options = paragraph.field_formio_render_options.value|default('{}') %}

{% set classes = [
  'paragraph--formio',
  'paragraph--formio--view-mode--' ~ view_mode|clean_class,
  'paragraph--formio--' ~ form_id,
]%}

{% block paragraph %}
  <div{{ attributes.addClass(classes) }}>
    <div id="formio-{{ form_id }}"
      data-source="{{- endpoint -}}" data-options="{{ options|escape }}">
    </div>

{% block content %}
<script>
   window.addEventListener('load', function() {
      var el = document.getElementById('formio-{{ form_id }}'); // keeping this as a DOM for patch.js
      var options = safeJSONParse(el.getAttribute('data-options'))
      Formio.createForm(el, el.getAttribute('data-source'), options)
        .then(function(form) {
        //perform sfoptions, hide certain elements
        if (options.sfoptions && options.sfoptions.hide instanceof Object) {
          customHideElements(options.sfoptions.hide)
        }
        // add css class to element(by id)
        if (options.sfoptions && options.sfoptions.addClass) {
          customAddCssClassById(options.sfoptions.addClass)
        }
        // if cookies are defined, populate the form field with cookie value.
        if(options.sfoptions instanceof Object && options.sfoptions.cookies){
          manageFormCookies(options.sfoptions["cookies"], form, true)
        }
        // perform custom action on nextPage event
        form.on('nextPage', function(){
          // set form cookies, if there are any
          if(options.sfoptions instanceof Object && options.sfoptions.cookies){
            manageFormCookies(options.sfoptions.cookies, form, false)
          }
        })
        // What to do when the submit begins.
        form.on('submitDone', function(submission) {
            // custom options defined in Form.io render options field
            if(options.redirects instanceof Object){
              if (options.sfoptions && options.sfoptions.hide instanceof Object) {
                customHideElements(options.sfoptions.hide)
              }
              for (var key in options.redirects) {
                var value = options.redirects[key]
                // only one "redirect" should be "yes", this is set in the form.io form
                if(submission.data[key] === "yes"){
                  window.location = value
                  break
                }
              }
            }
          // if confirmation url is set, this is for backward compatibility
          {% if paragraph.field_formio_confirmation_url.value %}
            window.location = '{{ paragraph.field_formio_confirmation_url.value }}';
          {% endif %}
        });
      });
      function customAddCssClassById(classes) {
        for (var key in classes) {
          var el = document.getElementById(key)
          if(el != null)
            el.classList.add(classes[key])
        }
      }

      function customHideElements(elements) {
        elements.forEach(function(klass, index) {
            var hide = document.getElementsByClassName(klass)
            for (var i = 0; i < hide.length; i++){
              hide[i].style.display = "none"
            }
          })
      }

      function setCookie(name, value){
        var today = new Date();
        var expiry = new Date(today.getTime() + 90 * 24 * 3600 * 1000); // plus 90 days
        document.cookie=name + "=" + escape(value) + "; path=/; expires=" + expiry.toGMTString();
      }

      function getCookie(name){
        var re = new RegExp(name + "=([^;]+)");
        var value = re.exec(document.cookie);
        return (value != null) ? unescape(value[1]) : null;
      }

      function setCheckboxRadioButton(field, cookieval, fieldtype) {
        if(!cookieval) return;

        if(cookieval.includes(field.value) ){
          field.prop('checked', true)
        }
      }

      function manageFormCookies(cookies, form, populateAll) {
        cookies.forEach(function(item, index){
          var field = $('input[name*="'+item+'"]') // use jquery to get dynamic field by name
          var fieldtype = field.prop('type')

          // special type: select, because formio renders select as divs
          var selectField = $('select[name*="'+item+'"]')[0]
          if(selectField){
            field = $(selectField) // convert to jQuery object
          }
          if(field || populateAll){
            var cookieval = getCookie(item)
            if(cookieval)
              form._submission.data[item] = cookieval //set submission data, form validation needs this

            if(field){ // populate fields with cookie values
                if(fieldtype !== undefined && (fieldtype === 'radio' || fieldtype === 'checkbox')){
                  setCheckboxRadioButton(field, cookieval, fieldtype)
                }else{
                  field.val(cookieval)
                }
            }else if(field){
              // set cookie for first time
              if(fieldtype !== undefined && (fieldtype === 'radio' || fieldtype === 'checkbox')){
                setCookie(item, field.prop('checked'))
              }
              else{
                setCookie(item, field.val())
              }
            } // updates cookie if value changed
            $(field).change( function(){
              console.log("setting cookie for " + item + " with value " + this.value)
              setCookie(item, this.value)
            })
          }
        })
      }

      function safeJSONParse(str) {
        var parsed = {}
        try {
          parsed = JSON.parse(str)
        } catch (error) {
          console.warn('Unable to parse form options:', str)
        }
        return parsed
      }
  });

</script>
{% endblock content %}

</div>
{% endblock paragraph %}
